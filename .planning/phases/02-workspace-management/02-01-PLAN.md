---
phase: 02-workspace-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/workspace/git-worktree.ts
autonomous: true

must_haves:
  truths:
    - "Git worktree list returns parsed array of worktree objects"
    - "Git worktree add creates new worktree with branch"
    - "Git worktree remove deletes worktree directory"
  artifacts:
    - path: "src/workspace/git-worktree.ts"
      provides: "Git worktree CLI operations"
      exports: ["listWorktrees", "addWorktree", "removeWorktree", "GitWorktree"]
    - path: "package.json"
      provides: "execa and nanoid dependencies"
      contains: "execa"
  key_links:
    - from: "src/workspace/git-worktree.ts"
      to: "git CLI"
      via: "execa $ template"
      pattern: "\\$.*git worktree"
---

<objective>
Create git worktree operations module using execa to execute git CLI commands.

Purpose: Git worktrees provide true filesystem isolation for each workspace. This module wraps git CLI commands with TypeScript types and error handling.

Output: `src/workspace/git-worktree.ts` with listWorktrees, addWorktree, removeWorktree functions
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workspace-management/02-RESEARCH.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install execa and nanoid dependencies</name>
  <files>package.json</files>
  <action>
Install execa v9.x and nanoid v5.x using npm:

```bash
npm install execa@^9 nanoid@^5
```

These are ESM-only packages which matches our project setup (type: "module").

- execa: Promise-based process execution with template strings, no shell injection risk
- nanoid: Short, URL-safe unique ID generation for workspace IDs
  </action>
  <verify>
`npm ls execa nanoid` shows both packages installed.
`npm run build` still succeeds (no breaking changes).
  </verify>
  <done>execa ^9.x and nanoid ^5.x appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create git-worktree.ts module</name>
  <files>src/workspace/git-worktree.ts</files>
  <action>
Create `src/workspace/git-worktree.ts` with:

**GitWorktree interface:**
```typescript
export interface GitWorktree {
  path: string;        // Absolute path to worktree directory
  head: string;        // Current HEAD commit SHA
  branch: string | null;  // Branch name (refs/heads/...) or null if detached
  bare: boolean;
  detached: boolean;
  locked: boolean;
  prunable: boolean;
}
```

**listWorktrees(repoPath: string): Promise<GitWorktree[]>**
- Execute `git worktree list --porcelain` using execa $ template
- Parse porcelain output (blocks separated by empty lines)
- Return typed array of GitWorktree objects
- Handle empty repo case (main worktree only)

**addWorktree(repoPath: string, worktreePath: string, branchName: string, baseBranch?: string): Promise<void>**
- Default baseBranch to 'main'
- Execute `git fetch origin` first to ensure refs are current
- Execute `git worktree add -b {branchName} {worktreePath} origin/{baseBranch}`
- Throw descriptive errors for:
  - Branch already exists
  - Branch already checked out in another worktree
  - Base branch doesn't exist

**removeWorktree(repoPath: string, worktreePath: string): Promise<void>**
- Execute `git worktree remove {worktreePath}`
- Do NOT use --force (let git protect uncommitted changes)
- If removal fails due to untracked files, throw with helpful message

**Error handling:**
- Catch execa errors and rethrow with context (e.g., "Failed to create worktree: branch 'foo' already exists")
- Use error.stderr for git error messages

Import execa using: `import { $ } from 'execa';`
Set cwd option for all git commands: `$({ cwd: repoPath })`
  </action>
  <verify>
`npm run build` succeeds with no TypeScript errors.
File exists at `src/workspace/git-worktree.ts`.
  </verify>
  <done>
git-worktree.ts exports GitWorktree interface and listWorktrees, addWorktree, removeWorktree functions.
All functions use execa $ template with proper cwd.
Error messages include git stderr output.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test script for git-worktree operations</name>
  <files>src/workspace/test-git-worktree.ts</files>
  <action>
Create `src/workspace/test-git-worktree.ts` that verifies the module works:

```typescript
import { listWorktrees, addWorktree, removeWorktree } from './git-worktree.js';
import { mkdtempSync, rmSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { $ } from 'execa';

async function test() {
  // Create temp directory for test repo
  const testDir = mkdtempSync(join(tmpdir(), 'equipe-test-'));
  const repoPath = join(testDir, 'repo');

  try {
    // Initialize a test git repo
    await $`git init ${repoPath}`;
    await $({ cwd: repoPath })`git config user.email test@test.com`;
    await $({ cwd: repoPath })`git config user.name Test`;
    await $({ cwd: repoPath })`git commit --allow-empty -m "initial"`;

    // Test listWorktrees (should show main worktree)
    console.log('Testing listWorktrees...');
    const worktrees = await listWorktrees(repoPath);
    console.log('Worktrees:', worktrees);
    if (worktrees.length !== 1) throw new Error('Expected 1 worktree');
    if (!worktrees[0].path.includes('repo')) throw new Error('Wrong path');
    console.log('✓ listWorktrees works');

    // Test addWorktree
    console.log('Testing addWorktree...');
    const worktreePath = join(testDir, 'worktree-feature');
    // Note: We can't test origin/main without a remote, so test with HEAD
    await $({ cwd: repoPath })`git worktree add -b feature ${worktreePath} HEAD`;
    const worktrees2 = await listWorktrees(repoPath);
    if (worktrees2.length !== 2) throw new Error('Expected 2 worktrees after add');
    console.log('✓ addWorktree works');

    // Test removeWorktree
    console.log('Testing removeWorktree...');
    await removeWorktree(repoPath, worktreePath);
    const worktrees3 = await listWorktrees(repoPath);
    if (worktrees3.length !== 1) throw new Error('Expected 1 worktree after remove');
    console.log('✓ removeWorktree works');

    console.log('\n✓ All tests passed!');
  } finally {
    // Cleanup
    rmSync(testDir, { recursive: true, force: true });
  }
}

test().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

Add npm script: `"test:worktree": "node dist/workspace/test-git-worktree.js"`
  </action>
  <verify>
`npm run build && npm run test:worktree` outputs "All tests passed!"
  </verify>
  <done>
Test script validates listWorktrees, addWorktree (via direct git command), and removeWorktree.
Test creates isolated temp repo, runs operations, and cleans up.
  </done>
</task>

</tasks>

<verification>
1. `npm ls execa nanoid` shows both dependencies
2. `npm run build` compiles without errors
3. `npm run test:worktree` passes all assertions
4. `src/workspace/git-worktree.ts` exists with exported functions
</verification>

<success_criteria>
- execa and nanoid installed as dependencies
- git-worktree.ts provides typed wrappers for git worktree CLI
- listWorktrees parses --porcelain output correctly
- Test script validates core operations work
</success_criteria>

<output>
After completion, create `.planning/phases/02-workspace-management/02-01-SUMMARY.md`
</output>
