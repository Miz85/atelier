---
phase: 02-workspace-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/workspace/workspace-manager.ts
  - src/state/workspace.ts
autonomous: true

must_haves:
  truths:
    - "createWorkspace creates git worktree and returns Workspace object"
    - "deleteWorkspace removes worktree and cleans up agent process"
    - "syncWorkspacesFromGit reconciles app state with git state"
  artifacts:
    - path: "src/workspace/workspace-manager.ts"
      provides: "Workspace lifecycle operations"
      exports: ["createWorkspace", "deleteWorkspace", "syncWorkspacesFromGit"]
  key_links:
    - from: "src/workspace/workspace-manager.ts"
      to: "src/workspace/git-worktree.ts"
      via: "import and call"
      pattern: "import.*git-worktree"
    - from: "src/workspace/workspace-manager.ts"
      to: "src/processes/cleanup.ts"
      via: "process cleanup on delete"
      pattern: "processRegistry"
---

<objective>
Create workspace manager that orchestrates git worktrees, process cleanup, and state updates.

Purpose: Workspace creation/deletion involves multiple steps (git worktree, state update, process management). This manager coordinates these operations atomically.

Output: `src/workspace/workspace-manager.ts` with createWorkspace, deleteWorkspace, syncWorkspacesFromGit
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-workspace-management/02-RESEARCH.md
@.planning/phases/02-workspace-management/02-01-SUMMARY.md
@src/workspace/git-worktree.ts
@src/state/workspace.ts
@src/processes/cleanup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace-manager.ts</name>
  <files>src/workspace/workspace-manager.ts</files>
  <action>
Create `src/workspace/workspace-manager.ts`:

**Imports:**
```typescript
import { nanoid } from 'nanoid';
import { dirname, join } from 'node:path';
import { addWorktree, removeWorktree, listWorktrees, type GitWorktree } from './git-worktree.js';
import { processRegistry } from '../processes/cleanup.js';
import type { Workspace } from '../state/workspace.js';
```

**CreateWorkspaceOptions interface:**
```typescript
export interface CreateWorkspaceOptions {
  repoPath: string;           // Path to the main git repository
  branchName: string;         // New branch name for this workspace
  name?: string;              // User-friendly name (defaults to branch name)
  agent?: 'claude' | 'opencode';  // Agent type (defaults to 'claude')
  baseBranch?: string;        // Base branch to create from (defaults to 'main')
}
```

**createWorkspace function:**
```typescript
/**
 * Create a new workspace with git worktree.
 *
 * Steps:
 * 1. Generate unique ID
 * 2. Compute worktree path (sibling to repo: /repo -> /repo-branchname)
 * 3. Create git worktree with new branch
 * 4. Return Workspace object (caller adds to state)
 *
 * Does NOT start agent - that's Phase 3.
 * Does NOT update state - caller handles that with Jotai.
 */
export async function createWorkspace(options: CreateWorkspaceOptions): Promise<Workspace> {
  const {
    repoPath,
    branchName,
    name = branchName,
    agent = 'claude',
    baseBranch = 'main',
  } = options;

  // Generate unique ID
  const id = nanoid();

  // Compute worktree path as sibling to repo
  // /path/to/repo -> /path/to/repo-feature-branch
  // Replace / in branch names with - for filesystem safety
  const safeBranchName = branchName.replace(/\//g, '-');
  const worktreePath = `${repoPath}-${safeBranchName}`;

  // Create git worktree
  await addWorktree(repoPath, worktreePath, branchName, baseBranch);

  // Create workspace record
  const now = new Date().toISOString();
  const workspace: Workspace = {
    id,
    name,
    path: worktreePath,
    branch: branchName,
    agent,
    pid: undefined,  // No agent running yet
    createdAt: now,
    lastActiveAt: now,
  };

  return workspace;
}
```

**deleteWorkspace function:**
```typescript
/**
 * Delete a workspace and its git worktree.
 *
 * Steps:
 * 1. Kill agent process if running (via PID in workspace)
 * 2. Remove git worktree
 * 3. Caller removes from state
 *
 * @param workspace - The workspace to delete
 * @param repoPath - Path to the main repository
 */
export async function deleteWorkspace(
  workspace: Workspace,
  repoPath: string
): Promise<void> {
  // Kill agent process if running
  if (workspace.pid !== undefined) {
    console.log(`[WorkspaceManager] Killing agent process ${workspace.pid}`);
    try {
      process.kill(workspace.pid, 'SIGTERM');
      // Give it a moment to exit gracefully
      await new Promise(resolve => setTimeout(resolve, 500));
      // Force kill if still running
      try {
        process.kill(workspace.pid, 0); // Check if still alive
        process.kill(workspace.pid, 'SIGKILL');
      } catch {
        // Process already dead, good
      }
    } catch (err) {
      // Process may already be dead
      console.log(`[WorkspaceManager] Process ${workspace.pid} already dead`);
    }
  }

  // Remove git worktree
  await removeWorktree(repoPath, workspace.path);
}
```

**syncWorkspacesFromGit function:**
```typescript
/**
 * Synchronize app state from git worktree state.
 *
 * Git worktrees are source of truth. This function:
 * - Identifies worktrees in git but not in app (to add)
 * - Identifies workspaces in app but not in git (to remove)
 * - Returns lists so caller can update state
 *
 * Called on app startup and after manual git operations.
 *
 * @param repoPath - Path to main repository
 * @param currentWorkspaces - Current workspaces from app state
 */
export async function syncWorkspacesFromGit(
  repoPath: string,
  currentWorkspaces: Workspace[]
): Promise<{
  toAdd: GitWorktree[];
  toRemove: Workspace[];
  unchanged: Workspace[];
}> {
  const gitWorktrees = await listWorktrees(repoPath);

  // Build lookup by path (path is unique identifier)
  const gitPaths = new Set(gitWorktrees.map(w => w.path));
  const appPaths = new Map(currentWorkspaces.map(w => [w.path, w]));

  // Worktrees in git but not in app -> need to add
  // Skip the main worktree (it's the repo itself, not a workspace)
  const mainRepoPath = repoPath;
  const toAdd = gitWorktrees.filter(gw =>
    !appPaths.has(gw.path) && gw.path !== mainRepoPath
  );

  // Workspaces in app but not in git -> need to remove
  const toRemove = currentWorkspaces.filter(w => !gitPaths.has(w.path));

  // Both exist -> unchanged
  const unchanged = currentWorkspaces.filter(w => gitPaths.has(w.path));

  return { toAdd, toRemove, unchanged };
}
```
  </action>
  <verify>
`npm run build` succeeds with no TypeScript errors.
File exports createWorkspace, deleteWorkspace, syncWorkspacesFromGit.
  </verify>
  <done>
workspace-manager.ts provides:
- createWorkspace: Creates worktree and returns Workspace object
- deleteWorkspace: Kills agent (if running) and removes worktree
- syncWorkspacesFromGit: Reconciles git state with app state
  </done>
</task>

<task type="auto">
  <name>Task 2: Add repoPath to state for sync operations</name>
  <files>src/state/workspace.ts</files>
  <action>
Add a persisted atom for the current repository path in `src/state/workspace.ts`:

```typescript
/**
 * Persisted atom for the current repository path.
 * Set when user opens a repository.
 * Used for git operations and workspace path computation.
 */
export const repoPathAtom = atomWithStorage<string | null>(
  'repoPath',
  null,
  createJotaiStorage<string | null>(),
  { getOnInit: true }
);
```

This enables the app to remember which repo it was working with and perform git operations without asking each time.
  </action>
  <verify>
`npm run build` succeeds.
workspace.ts exports repoPathAtom.
  </verify>
  <done>
workspace.ts now exports repoPathAtom for persisting the current repository path.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test script for workspace-manager</name>
  <files>src/workspace/test-workspace-manager.ts, package.json</files>
  <action>
Create `src/workspace/test-workspace-manager.ts`:

```typescript
import { createWorkspace, deleteWorkspace, syncWorkspacesFromGit } from './workspace-manager.js';
import { listWorktrees } from './git-worktree.js';
import { mkdtempSync, rmSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { $ } from 'execa';

async function test() {
  // Create temp directory for test
  const testDir = mkdtempSync(join(tmpdir(), 'equipe-wm-test-'));
  const repoPath = join(testDir, 'repo');

  try {
    // Initialize a test git repo
    console.log('Setting up test repo...');
    await $`git init ${repoPath}`;
    await $({ cwd: repoPath })`git config user.email test@test.com`;
    await $({ cwd: repoPath })`git config user.name Test`;
    await $({ cwd: repoPath })`git commit --allow-empty -m "initial"`;

    // Test 1: createWorkspace
    console.log('\nTest 1: createWorkspace');
    const workspace = await createWorkspace({
      repoPath,
      branchName: 'feature/test-workspace',
      name: 'Test Workspace',
      agent: 'claude',
      baseBranch: 'HEAD',  // Use HEAD since we don't have origin/main
    });

    console.log('Created workspace:', workspace);
    if (!workspace.id) throw new Error('Missing workspace ID');
    if (workspace.name !== 'Test Workspace') throw new Error('Wrong name');
    if (workspace.branch !== 'feature/test-workspace') throw new Error('Wrong branch');
    if (!workspace.path.includes('feature-test-workspace')) throw new Error('Wrong path');
    console.log('✓ createWorkspace works');

    // Verify worktree exists in git
    const worktrees = await listWorktrees(repoPath);
    console.log('Worktrees:', worktrees.length);
    if (worktrees.length !== 2) throw new Error('Expected 2 worktrees (main + new)');

    // Test 2: syncWorkspacesFromGit
    console.log('\nTest 2: syncWorkspacesFromGit');

    // With empty app state, should report workspace to add
    const sync1 = await syncWorkspacesFromGit(repoPath, []);
    console.log('Sync result (empty state):', {
      toAdd: sync1.toAdd.length,
      toRemove: sync1.toRemove.length,
      unchanged: sync1.unchanged.length,
    });
    if (sync1.toAdd.length !== 1) throw new Error('Should have 1 workspace to add');

    // With workspace in state, should be unchanged
    const sync2 = await syncWorkspacesFromGit(repoPath, [workspace]);
    console.log('Sync result (with state):', {
      toAdd: sync2.toAdd.length,
      toRemove: sync2.toRemove.length,
      unchanged: sync2.unchanged.length,
    });
    if (sync2.unchanged.length !== 1) throw new Error('Should have 1 unchanged');
    console.log('✓ syncWorkspacesFromGit works');

    // Test 3: deleteWorkspace
    console.log('\nTest 3: deleteWorkspace');
    await deleteWorkspace(workspace, repoPath);

    const worktreesAfter = await listWorktrees(repoPath);
    if (worktreesAfter.length !== 1) throw new Error('Expected 1 worktree after delete');
    console.log('✓ deleteWorkspace works');

    console.log('\n✓ All workspace-manager tests passed!');
  } finally {
    // Cleanup
    rmSync(testDir, { recursive: true, force: true });
  }
}

test().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

Add npm script: `"test:workspace-manager": "node dist/workspace/test-workspace-manager.js"`
  </action>
  <verify>
`npm run build && npm run test:workspace-manager` outputs "All workspace-manager tests passed!"
  </verify>
  <done>
Test validates:
- createWorkspace creates git worktree and returns Workspace
- syncWorkspacesFromGit correctly identifies changes
- deleteWorkspace removes git worktree
  </done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm run test:workspace-manager` passes all tests
3. workspace-manager.ts exports all three functions
4. workspace.ts exports repoPathAtom
</verification>

<success_criteria>
- createWorkspace orchestrates worktree creation with proper ID generation
- deleteWorkspace cleans up agent process and removes worktree
- syncWorkspacesFromGit enables reconciliation with git state
- repoPathAtom enables persisting repository context
</success_criteria>

<output>
After completion, create `.planning/phases/02-workspace-management/02-03-SUMMARY.md`
</output>
