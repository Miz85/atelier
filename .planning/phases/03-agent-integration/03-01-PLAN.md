---
phase: 03-agent-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/spawn.ts
  - src/agents/types.ts
autonomous: true

must_haves:
  truths:
    - "Agent process can be spawned in workspace directory"
    - "Agent process emits output via onData callback"
    - "Agent process can be stopped gracefully"
    - "Agent process can be restarted after stopping"
  artifacts:
    - path: "src/agents/types.ts"
      provides: "AgentType, AgentInstance, AgentEvents interfaces"
      exports: ["AgentType", "AgentInstance", "AgentEvents"]
    - path: "src/agents/spawn.ts"
      provides: "spawnAgent, stopAgent, restartAgent functions"
      exports: ["spawnAgent", "stopAgent", "restartAgent", "sendInput"]
  key_links:
    - from: "src/agents/spawn.ts"
      to: "src/processes/pty-manager.ts"
      via: "BufferedPtyProcess import"
      pattern: "import.*BufferedPtyProcess.*from.*pty-manager"
    - from: "src/agents/spawn.ts"
      to: "src/processes/cleanup.ts"
      via: "processRegistry import for tracking"
      pattern: "import.*processRegistry.*from.*cleanup"
---

<objective>
Create the core agent spawning module that handles spawning Claude Code or OpenCode in a workspace directory, with lifecycle operations (stop, restart) and input/output streaming.

Purpose: This is the foundation for all agent interaction - without this module, workspaces cannot run agents.
Output: src/agents/spawn.ts with spawnAgent, stopAgent, restartAgent, sendInput functions
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-integration/03-RESEARCH.md

# Existing infrastructure to use
@src/processes/pty-manager.ts
@src/processes/cleanup.ts
@src/state/workspace.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent types</name>
  <files>src/agents/types.ts</files>
  <action>
Create src/agents/types.ts with:

1. AgentType union: 'claude' | 'opencode'

2. AgentCommand mapping: Map AgentType to actual CLI command
   - 'claude' -> 'claude' (Claude Code CLI)
   - 'opencode' -> 'opencode' (OpenCode CLI)

3. AgentInstance interface:
   - id: string (unique agent instance ID)
   - workspaceId: string (links to Workspace)
   - type: AgentType
   - pty: BufferedPtyProcess
   - status: 'running' | 'stopped' | 'error'
   - startedAt: string (ISO timestamp)
   - stoppedAt?: string (ISO timestamp, set when stopped)

4. AgentEvents interface (callbacks):
   - onData: (data: string) => void
   - onExit: (exitCode: number, signal?: number) => void
   - onError?: (error: Error) => void

Import BufferedPtyProcess type from '../processes/pty-manager.js'
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>types.ts exports AgentType, AgentCommand, AgentInstance, AgentEvents</done>
</task>

<task type="auto">
  <name>Task 2: Create agent spawn module</name>
  <files>src/agents/spawn.ts</files>
  <action>
Create src/agents/spawn.ts implementing agent lifecycle:

1. agentInstances Map: Track all running agents by ID (in-memory, not persisted)
   - Map<string, AgentInstance>

2. spawnAgent function:
   ```typescript
   function spawnAgent(
     workspaceId: string,
     workspacePath: string,
     agentType: AgentType,
     events: AgentEvents
   ): AgentInstance
   ```
   - Generate unique ID: `agent-${workspaceId}-${Date.now()}`
   - Look up command from AgentCommand mapping
   - Use BufferedPtyProcess to spawn agent:
     - command: AgentCommand[agentType]
     - cwd: workspacePath
     - cols: process.stdout.columns || 80
     - rows: process.stdout.rows || 30
   - Wire up events: pty.on({ onData: events.onData, onExit: ... })
   - On exit: update status to 'stopped', set stoppedAt, call events.onExit
   - Add to agentInstances map
   - Return the AgentInstance

3. stopAgent function:
   ```typescript
   async function stopAgent(agentId: string): Promise<void>
   ```
   - Get instance from agentInstances map
   - Throw if not found
   - If already stopped, return early
   - Call pty.kill('SIGTERM')
   - Wait up to 5 seconds for exit
   - If timeout, call pty.kill('SIGKILL')
   - Update status to 'stopped'
   - NOTE: Do NOT remove from map - needed for restart

4. restartAgent function:
   ```typescript
   function restartAgent(
     agentId: string,
     events: AgentEvents
   ): AgentInstance
   ```
   - Get old instance from agentInstances map
   - Throw if not found
   - Throw if status is 'running' (must stop first)
   - Stop old instance if not already stopped
   - Remove old instance from map
   - Spawn new agent with same workspaceId, workspacePath, agentType
   - Return new AgentInstance

5. sendInput function:
   ```typescript
   function sendInput(agentId: string, input: string): void
   ```
   - Get instance from agentInstances map
   - Throw if not found or not running
   - Call pty.write(input + '\r') - PTY requires \r for Enter, not \n

6. getAgentInstance function:
   ```typescript
   function getAgentInstance(agentId: string): AgentInstance | undefined
   ```
   - Return from agentInstances map

7. getAgentByWorkspace function:
   ```typescript
   function getAgentByWorkspace(workspaceId: string): AgentInstance | undefined
   ```
   - Find agent where instance.workspaceId === workspaceId

Export all functions.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>spawn.ts exports spawnAgent, stopAgent, restartAgent, sendInput, getAgentInstance, getAgentByWorkspace</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Types are correctly exported: Check dist/agents/types.d.ts and dist/agents/spawn.d.ts exist
3. No circular dependencies: spawn.ts imports from pty-manager.ts, not vice versa
</verification>

<success_criteria>
- src/agents/types.ts defines AgentType, AgentInstance, AgentEvents
- src/agents/spawn.ts implements spawnAgent, stopAgent, restartAgent, sendInput
- All functions use BufferedPtyProcess from existing pty-manager.ts
- Process tracking uses existing processRegistry (via BufferedPtyProcess)
- Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-integration/03-01-SUMMARY.md`
</output>
