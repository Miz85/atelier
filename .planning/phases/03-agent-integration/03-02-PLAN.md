---
phase: 03-agent-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/state/agents.ts
autonomous: true

must_haves:
  truths:
    - "Agent output is stored per workspace"
    - "Agent status is tracked reactively"
    - "UI can subscribe to agent output updates"
  artifacts:
    - path: "src/state/agents.ts"
      provides: "Agent state atoms for reactive UI updates"
      exports: ["agentOutputAtom", "agentStatusAtom", "appendAgentOutput", "setAgentStatus", "clearAgentOutput"]
  key_links:
    - from: "src/state/agents.ts"
      to: "jotai"
      via: "atom import"
      pattern: "import.*atom.*from.*jotai"
---

<objective>
Create Jotai atoms for managing agent state reactively, enabling UI components to subscribe to agent output and status changes.

Purpose: Connects agent process events to React UI via reactive state management.
Output: src/state/agents.ts with atoms for output, status, and helper functions
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-agent-integration/03-RESEARCH.md

# Types from Plan 01
@src/agents/types.ts

# Existing state patterns
@src/state/workspace.ts
@src/state/settings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent state atoms</name>
  <files>src/state/agents.ts</files>
  <action>
Create src/state/agents.ts with reactive state for agent UI:

1. Import atom from 'jotai' (NOT atomWithStorage - agent state is ephemeral, not persisted)

2. AgentStatus type:
   ```typescript
   type AgentStatus = 'idle' | 'running' | 'stopped' | 'error';
   ```

3. WorkspaceAgentState interface:
   ```typescript
   interface WorkspaceAgentState {
     agentId: string | null;      // Current agent instance ID
     status: AgentStatus;
     outputLines: string[];       // Streaming output lines
     error?: string;              // Error message if status === 'error'
   }
   ```

4. agentStateByWorkspaceAtom:
   ```typescript
   const agentStateByWorkspaceAtom = atom<Map<string, WorkspaceAgentState>>(new Map());
   ```
   - Maps workspaceId -> WorkspaceAgentState
   - NOT persisted (ephemeral - agents restart on app restart anyway)

5. Helper atom factories for per-workspace access:

   a. getAgentStateAtom(workspaceId: string):
      - Returns derived atom that reads state for specific workspace
      - Returns default state if workspace not in map: { agentId: null, status: 'idle', outputLines: [] }

   b. getAgentOutputAtom(workspaceId: string):
      - Returns derived atom with just outputLines for workspace

   c. getAgentStatusAtom(workspaceId: string):
      - Returns derived atom with just status for workspace

6. Action functions (to be called from agent spawn module):

   a. setAgentState(workspaceId: string, state: Partial<WorkspaceAgentState>):
      - Merges partial state into existing state for workspace
      - Creates entry if doesn't exist

   b. appendAgentOutput(workspaceId: string, output: string):
      - Appends output to outputLines array
      - Split by newlines and append each line
      - Limit to last 1000 lines to prevent memory bloat

   c. setAgentStatus(workspaceId: string, status: AgentStatus, error?: string):
      - Sets status and optionally error message

   d. clearAgentOutput(workspaceId: string):
      - Clears outputLines array (useful before restart)

   e. initAgentState(workspaceId: string, agentId: string):
      - Creates fresh state for workspace with agentId
      - status: 'running', outputLines: [], no error

   f. removeAgentState(workspaceId: string):
      - Removes state entry for workspace (when workspace deleted)

7. Export:
   - AgentStatus type
   - WorkspaceAgentState interface
   - agentStateByWorkspaceAtom
   - All helper atom factories
   - All action functions

NOTE: These atoms are designed to be used with Jotai's useAtom hook in components.
The action functions need to be called with a Jotai store's set function or via useSetAtom.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>agents.ts exports all atoms, types, and helper functions for agent state management</done>
</task>

<task type="auto">
  <name>Task 2: Create atom action hooks for components</name>
  <files>src/state/agents.ts</files>
  <action>
Extend src/state/agents.ts with React hooks for component use:

1. Add atom-based action creators that components can use with useSetAtom:

   a. appendOutputAtom:
      ```typescript
      const appendOutputAtom = atom(
        null,
        (get, set, { workspaceId, output }: { workspaceId: string; output: string }) => {
          const stateMap = get(agentStateByWorkspaceAtom);
          const current = stateMap.get(workspaceId) || { agentId: null, status: 'idle', outputLines: [] };

          // Split output by newlines and append
          const newLines = output.split(/\r?\n/);
          const updatedLines = [...current.outputLines, ...newLines].slice(-1000); // Keep last 1000

          const newMap = new Map(stateMap);
          newMap.set(workspaceId, { ...current, outputLines: updatedLines });
          set(agentStateByWorkspaceAtom, newMap);
        }
      );
      ```

   b. setStatusAtom:
      ```typescript
      const setStatusAtom = atom(
        null,
        (get, set, { workspaceId, status, error }: { workspaceId: string; status: AgentStatus; error?: string }) => {
          // Similar pattern - update status in map
        }
      );
      ```

   c. initAgentStateAtom:
      ```typescript
      const initAgentStateAtom = atom(
        null,
        (get, set, { workspaceId, agentId }: { workspaceId: string; agentId: string }) => {
          const stateMap = get(agentStateByWorkspaceAtom);
          const newMap = new Map(stateMap);
          newMap.set(workspaceId, {
            agentId,
            status: 'running',
            outputLines: [],
          });
          set(agentStateByWorkspaceAtom, newMap);
        }
      );
      ```

   d. clearOutputAtom:
      ```typescript
      const clearOutputAtom = atom(
        null,
        (get, set, workspaceId: string) => {
          // Clear outputLines for workspace
        }
      );
      ```

2. Export these action atoms for use with useSetAtom in components:
   - appendOutputAtom
   - setStatusAtom
   - initAgentStateAtom
   - clearOutputAtom
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>agents.ts exports action atoms that can be used with useSetAtom in React components</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. atoms.ts is properly typed: Check no 'any' types, all generics specified
3. Atoms follow Jotai patterns: Readable atoms use atom(get => ...), writable atoms use atom(null, (get, set, value) => ...)
</verification>

<success_criteria>
- src/state/agents.ts exports AgentStatus, WorkspaceAgentState types
- Atoms track agent state per workspace (not globally)
- Action atoms allow components to update state reactively
- Output lines are capped at 1000 to prevent memory bloat
- State is NOT persisted (ephemeral - agents don't survive app restart)
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-integration/03-02-SUMMARY.md`
</output>
