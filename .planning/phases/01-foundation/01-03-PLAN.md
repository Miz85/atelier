---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/processes/cleanup.ts
  - src/processes/lifecycle.ts
  - src/processes/pty-manager.ts
autonomous: true

must_haves:
  truths:
    - "All spawned processes are tracked in registry"
    - "SIGINT, SIGTERM, SIGHUP, SIGQUIT trigger cleanup"
    - "PTY data is buffered until exit event (prevents data loss)"
    - "Process tree is killed on cleanup (no zombies)"
  artifacts:
    - path: "src/processes/cleanup.ts"
      provides: "Process registry and cleanup"
      exports: ["ProcessRegistry", "processRegistry"]
    - path: "src/processes/lifecycle.ts"
      provides: "Signal handlers"
      exports: ["setupGracefulShutdown"]
    - path: "src/processes/pty-manager.ts"
      provides: "Buffered PTY wrapper"
      exports: ["BufferedPtyProcess"]
  key_links:
    - from: "src/processes/lifecycle.ts"
      to: "src/processes/cleanup.ts"
      via: "calls processRegistry.cleanup()"
      pattern: "processRegistry\\.cleanup"
    - from: "src/processes/cleanup.ts"
      to: "terminate"
      via: "kills process trees"
      pattern: "terminate\\("
    - from: "src/processes/pty-manager.ts"
      to: "src/processes/cleanup.ts"
      via: "registers PID on spawn"
      pattern: "processRegistry\\.register"
---

<objective>
Implement process lifecycle management: cleanup registry, signal handlers, and buffered PTY manager to prevent zombie processes and terminal corruption.

Purpose: Enables success criteria 4 (terminal usable after crash) and 5 (no zombie processes).
Output: Robust process management infrastructure.
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create process cleanup registry</name>
  <files>src/processes/cleanup.ts</files>
  <action>
Create process registry that tracks all spawned PIDs and kills them on cleanup.

```typescript
// src/processes/cleanup.ts
import terminate from 'terminate';

/**
 * Registry for all spawned processes.
 * Ensures cleanup kills entire process trees to prevent zombies.
 */
export class ProcessRegistry {
  private processes = new Map<number, string>(); // PID -> description
  private cleanupInProgress = false;

  /**
   * Register a process for cleanup tracking.
   * @param pid Process ID to track
   * @param description Human-readable description for logging
   */
  register(pid: number, description: string = 'unknown'): void {
    this.processes.set(pid, description);
    console.log(`[ProcessRegistry] Registered PID ${pid} (${description})`);
  }

  /**
   * Unregister a process (e.g., when it exits normally).
   */
  unregister(pid: number): void {
    const desc = this.processes.get(pid);
    if (this.processes.delete(pid)) {
      console.log(`[ProcessRegistry] Unregistered PID ${pid} (${desc})`);
    }
  }

  /**
   * Check if a process is registered.
   */
  has(pid: number): boolean {
    return this.processes.has(pid);
  }

  /**
   * Get count of registered processes.
   */
  get count(): number {
    return this.processes.size;
  }

  /**
   * Kill all registered processes and their children.
   * Safe to call multiple times (idempotent).
   */
  cleanup(): void {
    if (this.cleanupInProgress) {
      console.log('[ProcessRegistry] Cleanup already in progress, skipping');
      return;
    }
    this.cleanupInProgress = true;

    if (this.processes.size === 0) {
      console.log('[ProcessRegistry] No processes to clean up');
      return;
    }

    console.log(`[ProcessRegistry] Cleaning up ${this.processes.size} process(es)...`);

    // Kill all registered processes and their children
    for (const [pid, description] of this.processes) {
      console.log(`[ProcessRegistry] Terminating PID ${pid} (${description})...`);

      try {
        // Use terminate package to kill entire process tree
        terminate(pid, 'SIGTERM', (err) => {
          if (err) {
            console.error(`[ProcessRegistry] SIGTERM failed for ${pid}:`, err.message);
            // Fallback to SIGKILL if SIGTERM fails
            try {
              process.kill(pid, 'SIGKILL');
              console.log(`[ProcessRegistry] SIGKILL sent to ${pid}`);
            } catch (killErr) {
              // Process may already be dead, ignore
              console.log(`[ProcessRegistry] Process ${pid} already dead`);
            }
          } else {
            console.log(`[ProcessRegistry] Terminated PID ${pid}`);
          }
        });
      } catch (err) {
        console.error(`[ProcessRegistry] Error terminating ${pid}:`, err);
      }
    }

    this.processes.clear();
    console.log('[ProcessRegistry] Cleanup complete');
  }
}

// Global singleton - must be imported to track all processes
export const processRegistry = new ProcessRegistry();
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
  </verify>
  <done>
ProcessRegistry class tracks PIDs with descriptions.
cleanup() kills entire process trees using terminate package.
SIGTERM with SIGKILL fallback for stubborn processes.
Global singleton exported for app-wide use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create signal handlers for graceful shutdown</name>
  <files>src/processes/lifecycle.ts</files>
  <action>
Create comprehensive signal handling for all exit paths.

```typescript
// src/processes/lifecycle.ts
import { processRegistry } from './cleanup.js';

/**
 * Setup graceful shutdown handlers for all termination signals.
 * MUST be called early in app lifecycle, before spawning any processes.
 *
 * Handles:
 * - SIGINT (Ctrl+C)
 * - SIGTERM (Docker/systemd stop)
 * - SIGHUP (terminal closed)
 * - SIGQUIT (Ctrl+\)
 * - uncaughtException
 * - unhandledRejection
 */
export function setupGracefulShutdown(
  additionalCleanup?: () => void | Promise<void>
): void {
  let shutdownInProgress = false;

  const shutdown = async (reason: string, exitCode: number = 0) => {
    if (shutdownInProgress) {
      console.log(`[Lifecycle] Shutdown already in progress (${reason})`);
      return;
    }
    shutdownInProgress = true;

    console.log(`\n[Lifecycle] Shutdown initiated: ${reason}`);

    // Set timeout to force exit if cleanup hangs
    const forceExitTimeout = setTimeout(() => {
      console.error('[Lifecycle] Cleanup timeout (5s), forcing exit');
      process.exit(1);
    }, 5000);

    try {
      // Run additional cleanup first (e.g., save state, close connections)
      if (additionalCleanup) {
        console.log('[Lifecycle] Running additional cleanup...');
        await additionalCleanup();
      }

      // Kill all tracked processes
      processRegistry.cleanup();

      // Restore terminal state (in case raw mode was enabled)
      if (process.stdin.isTTY) {
        try {
          process.stdin.setRawMode(false);
        } catch {
          // May fail if stdin not in raw mode, ignore
        }
      }

      clearTimeout(forceExitTimeout);
      console.log('[Lifecycle] Shutdown complete');
      process.exit(exitCode);
    } catch (error) {
      clearTimeout(forceExitTimeout);
      console.error('[Lifecycle] Cleanup error:', error);
      process.exit(1);
    }
  };

  // Signal handlers
  const signalHandler = (signal: NodeJS.Signals) => {
    // Standard exit codes: 128 + signal number
    const signalCodes: Record<string, number> = {
      'SIGINT': 130,   // 128 + 2
      'SIGTERM': 143,  // 128 + 15
      'SIGHUP': 129,   // 128 + 1
      'SIGQUIT': 131,  // 128 + 3
    };
    shutdown(signal, signalCodes[signal] ?? 1);
  };

  process.on('SIGINT', () => signalHandler('SIGINT'));
  process.on('SIGTERM', () => signalHandler('SIGTERM'));
  process.on('SIGHUP', () => signalHandler('SIGHUP'));
  process.on('SIGQUIT', () => signalHandler('SIGQUIT'));

  // Error handlers
  process.on('uncaughtException', (error) => {
    console.error('[Lifecycle] Uncaught exception:', error);
    shutdown('uncaughtException', 1);
  });

  process.on('unhandledRejection', (reason) => {
    console.error('[Lifecycle] Unhandled rejection:', reason);
    shutdown('unhandledRejection', 1);
  });

  // Note: process.on('exit') only allows sync code
  // Heavy cleanup done in signal handlers above
  process.on('exit', (code) => {
    console.log(`[Lifecycle] Process exiting with code ${code}`);
  });

  console.log('[Lifecycle] Graceful shutdown handlers registered');
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
  </verify>
  <done>
setupGracefulShutdown() handles SIGINT, SIGTERM, SIGHUP, SIGQUIT.
Handles uncaughtException and unhandledRejection.
5-second timeout forces exit if cleanup hangs.
Restores terminal raw mode on exit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create buffered PTY process manager</name>
  <files>src/processes/pty-manager.ts</files>
  <action>
Create PTY wrapper that buffers data until exit event (prevents race condition data loss).

```typescript
// src/processes/pty-manager.ts
import * as pty from 'node-pty';
import { processRegistry } from './cleanup.js';

export interface PtyOptions {
  command: string;
  args?: string[];
  cwd?: string;
  env?: Record<string, string>;
  cols?: number;
  rows?: number;
}

export interface PtyEvents {
  onData?: (data: string) => void;
  onExit?: (exitCode: number, signal?: number) => void;
}

/**
 * Buffered PTY process wrapper.
 *
 * Addresses node-pty race condition where data events can fire after exit event.
 * Pattern: Buffer all data until exit, then flush (VS Code approach).
 *
 * @see https://github.com/microsoft/node-pty/issues/72
 */
export class BufferedPtyProcess {
  private ptyProcess: pty.IPty;
  private dataBuffer: string[] = [];
  private exitReceived = false;
  private _exitCode: number | undefined;
  private events: PtyEvents = {};

  constructor(options: PtyOptions) {
    const {
      command,
      args = [],
      cwd = process.cwd(),
      env = process.env as Record<string, string>,
      cols = 80,
      rows = 24,
    } = options;

    this.ptyProcess = pty.spawn(command, args, {
      name: 'xterm-256color',
      cols,
      rows,
      cwd,
      env,
    });

    // Register for cleanup
    processRegistry.register(this.ptyProcess.pid, `PTY: ${command} ${args.join(' ')}`);

    // Buffer all data events
    this.ptyProcess.onData((data) => {
      if (this.exitReceived) {
        // Edge case: data after exit - flush immediately
        console.log('[PTY] Data received after exit, flushing');
        this.dataBuffer.push(data);
        this.flushBuffer();
      } else {
        // Normal case: buffer data
        this.dataBuffer.push(data);
        // Also emit immediately for real-time streaming
        this.events.onData?.(data);
      }
    });

    // Exit event marks end of data stream
    this.ptyProcess.onExit(({ exitCode, signal }) => {
      this.exitReceived = true;
      this._exitCode = exitCode;

      // Unregister from cleanup (process already exited)
      processRegistry.unregister(this.ptyProcess.pid);

      // Flush any remaining buffered data
      this.flushBuffer();

      // Notify listener
      this.events.onExit?.(exitCode, signal);
    });
  }

  /**
   * Get process ID.
   */
  get pid(): number {
    return this.ptyProcess.pid;
  }

  /**
   * Get exit code (undefined if still running).
   */
  get exitCode(): number | undefined {
    return this._exitCode;
  }

  /**
   * Check if process has exited.
   */
  get hasExited(): boolean {
    return this.exitReceived;
  }

  /**
   * Get all buffered output (useful for getting complete output after exit).
   */
  get allOutput(): string {
    return this.dataBuffer.join('');
  }

  /**
   * Register event handlers.
   */
  on(events: PtyEvents): void {
    this.events = { ...this.events, ...events };
  }

  /**
   * Write data to PTY stdin.
   */
  write(data: string): void {
    if (!this.exitReceived) {
      this.ptyProcess.write(data);
    }
  }

  /**
   * Resize PTY.
   */
  resize(cols: number, rows: number): void {
    if (!this.exitReceived) {
      this.ptyProcess.resize(cols, rows);
    }
  }

  /**
   * Kill the process.
   */
  kill(signal: string = 'SIGTERM'): void {
    if (!this.exitReceived) {
      this.ptyProcess.kill(signal);
    }
  }

  private flushBuffer(): void {
    // Buffer already emitted via onData in real-time
    // This method exists for the edge case of data-after-exit
    // In that case, we re-emit the late data
    if (this.exitReceived && this.dataBuffer.length > 0) {
      // Already flushed via onData events
    }
  }
}

/**
 * Spawn a buffered PTY process.
 * Convenience function.
 */
export function spawnPty(
  command: string,
  args: string[] = [],
  options: Partial<PtyOptions> = {}
): BufferedPtyProcess {
  return new BufferedPtyProcess({
    command,
    args,
    ...options,
  });
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
  </verify>
  <done>
BufferedPtyProcess wraps node-pty with data buffering.
Auto-registers PID with processRegistry on spawn.
Auto-unregisters on exit.
Handles data-after-exit edge case.
Provides allOutput getter for complete output after exit.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. All three modules export correctly
3. Code review: terminate package used for tree kill
4. Code review: All four signals handled (SIGINT, SIGTERM, SIGHUP, SIGQUIT)
5. Code review: PTY data is buffered and emitted on exit
</verification>

<success_criteria>
- ProcessRegistry tracks all spawned PIDs
- cleanup() kills entire process trees (not just parent)
- All termination signals trigger graceful shutdown
- Terminal raw mode restored on exit
- PTY data buffered to prevent race condition loss
- 5-second timeout prevents hanging on cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
