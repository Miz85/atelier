---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/storage.ts
  - src/state/workspace.ts
  - src/state/settings.ts
autonomous: true

must_haves:
  truths:
    - "FileSystemStorage adapter reads and writes to disk"
    - "Workspace state persists across process restarts"
    - "Settings atoms provide reactive access to configuration"
  artifacts:
    - path: "src/config/storage.ts"
      provides: "Custom Jotai storage adapter for Node.js"
      exports: ["FileSystemStorage", "fsStorage"]
    - path: "src/state/workspace.ts"
      provides: "Workspace state atoms"
      exports: ["workspacesAtom", "Workspace"]
    - path: "src/state/settings.ts"
      provides: "Settings state atoms"
      exports: ["settingsAtom"]
  key_links:
    - from: "src/state/workspace.ts"
      to: "src/config/storage.ts"
      via: "atomWithStorage using fsStorage"
      pattern: "atomWithStorage.*fsStorage"
    - from: "src/config/storage.ts"
      to: "write-file-atomic"
      via: "atomic file writes"
      pattern: "writeFileAtomic"
---

<objective>
Implement custom Jotai storage adapter for Node.js and create state atoms for workspace and settings persistence.

Purpose: Enables UI-04 (app persists workspace state) and UI-05 (app restores workspaces on launch).
Output: Reactive state management with filesystem persistence.
</objective>

<execution_context>
@/Users/nazim.saouli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nazim.saouli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileSystemStorage adapter for Jotai</name>
  <files>src/config/storage.ts</files>
  <action>
Create custom storage adapter since localStorage is unavailable in Node.js.

```typescript
// src/config/storage.ts
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import writeFileAtomic from 'write-file-atomic';

/**
 * Custom storage adapter for Jotai's atomWithStorage in Node.js.
 * Uses write-file-atomic for safe persistence (prevents corruption on crash).
 */
export class FileSystemStorage {
  private storageDir: string;

  constructor(storageDir?: string) {
    // Default: ~/.equipe/state (XDG-adjacent, simple for CLI tool)
    this.storageDir = storageDir ?? path.join(os.homedir(), '.equipe', 'state');

    // Ensure storage directory exists
    if (!fs.existsSync(this.storageDir)) {
      fs.mkdirSync(this.storageDir, { recursive: true });
    }
  }

  private getFilePath(key: string): string {
    // Sanitize key for filesystem safety
    const sanitized = key.replace(/[^a-zA-Z0-9-_]/g, '-');
    return path.join(this.storageDir, `${sanitized}.json`);
  }

  getItem<T>(key: string, initialValue: T): T {
    const filePath = this.getFilePath(key);
    try {
      if (fs.existsSync(filePath)) {
        const data = fs.readFileSync(filePath, 'utf-8');
        return JSON.parse(data) as T;
      }
    } catch (error) {
      console.error(`Error reading ${key} from storage:`, error);
    }
    return initialValue;
  }

  setItem<T>(key: string, value: T): void {
    const filePath = this.getFilePath(key);
    try {
      // Use write-file-atomic to prevent corruption on crash/power loss
      const data = JSON.stringify(value, null, 2);
      writeFileAtomic.sync(filePath, data, { encoding: 'utf-8' });
    } catch (error) {
      console.error(`Error writing ${key} to storage:`, error);
    }
  }

  removeItem(key: string): void {
    const filePath = this.getFilePath(key);
    try {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    } catch (error) {
      console.error(`Error removing ${key} from storage:`, error);
    }
  }

  // Required by Jotai's createJSONStorage
  subscribe(key: string, callback: (value: unknown) => void, initialValue: unknown): () => void {
    // For single-process CLI, no cross-process sync needed
    // Return no-op unsubscribe
    return () => {};
  }
}

// Global singleton for app-wide usage
export const fsStorage = new FileSystemStorage();

/**
 * Create Jotai-compatible storage wrapper.
 * Usage: atomWithStorage('key', defaultValue, createJotaiStorage())
 */
export function createJotaiStorage<T>() {
  return {
    getItem: (key: string, initialValue: T): T => fsStorage.getItem(key, initialValue),
    setItem: (key: string, value: T): void => fsStorage.setItem(key, value),
    removeItem: (key: string): void => fsStorage.removeItem(key),
    subscribe: fsStorage.subscribe.bind(fsStorage),
  };
}
```

Note: This is a synchronous implementation. Jotai's atomWithStorage expects sync getItem for initial hydration.
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check that no localStorage references exist in the code.
  </verify>
  <done>
FileSystemStorage class implemented with getItem, setItem, removeItem, subscribe methods.
Uses write-file-atomic for safe writes.
Creates ~/.equipe/state directory on first use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workspace and settings state atoms</name>
  <files>src/state/workspace.ts, src/state/settings.ts</files>
  <action>
Create workspace state atom with persistence:

```typescript
// src/state/workspace.ts
import { atomWithStorage } from 'jotai/utils';
import { createJotaiStorage } from '../config/storage.js';

/**
 * Workspace represents an isolated coding agent workspace.
 * Each workspace has its own git worktree and agent instance.
 */
export interface Workspace {
  id: string;                        // Unique identifier (UUID)
  name: string;                      // User-friendly name
  path: string;                      // Filesystem path to worktree
  branch: string;                    // Git branch name
  agent: 'claude' | 'opencode';      // Agent type for this workspace
  pid?: number;                      // Agent process ID (if running)
  createdAt: string;                 // ISO timestamp
  lastActiveAt: string;              // ISO timestamp
}

/**
 * Persistent atom for all workspaces.
 * Persists to ~/.equipe/state/workspaces.json
 */
export const workspacesAtom = atomWithStorage<Workspace[]>(
  'workspaces',
  [],
  createJotaiStorage<Workspace[]>(),
  { getOnInit: true } // Load from disk on initialization
);
```

Create settings state atom:

```typescript
// src/state/settings.ts
import { atomWithStorage } from 'jotai/utils';
import { createJotaiStorage } from '../config/storage.js';

/**
 * User settings stored via Jotai (separate from conf for reactive updates).
 * Note: This duplicates some conf settings to enable reactive UI updates.
 * The conf store remains source of truth; this syncs on app start.
 */
export interface Settings {
  ideCommand: string;
  defaultAgent: 'claude' | 'opencode';
}

export const settingsDefaults: Settings = {
  ideCommand: 'code',
  defaultAgent: 'claude',
};

/**
 * Persistent settings atom.
 * Persists to ~/.equipe/state/settings.json
 */
export const settingsAtom = atomWithStorage<Settings>(
  'settings',
  settingsDefaults,
  createJotaiStorage<Settings>(),
  { getOnInit: true }
);
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Verify exports are correct with: `node -e "import('./dist/state/workspace.js').then(m => console.log(Object.keys(m)))"`
  </verify>
  <done>
Workspace type defined with all fields.
workspacesAtom persists workspace array to disk.
settingsAtom persists user settings to disk.
Both use getOnInit: true for hydration on load.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test script for state persistence</name>
  <files>src/state/test-state.ts</files>
  <action>
Create test script to verify state persistence works:

```typescript
// src/state/test-state.ts
// Temporary test script - verifies Jotai + filesystem storage

import { createStore } from 'jotai';
import { workspacesAtom, Workspace } from './workspace.js';
import { settingsAtom, Settings } from './settings.js';
import { fsStorage } from '../config/storage.js';
import * as crypto from 'node:crypto';

console.log('=== State Persistence Test ===\n');

// Create Jotai store (simulates what Ink Provider would do)
const store = createStore();

// Test 1: Read initial state (should be empty or previous)
console.log('--- Initial State ---');
const initialWorkspaces = store.get(workspacesAtom);
const initialSettings = store.get(settingsAtom);
console.log('Workspaces:', JSON.stringify(initialWorkspaces, null, 2));
console.log('Settings:', JSON.stringify(initialSettings, null, 2));

// Test 2: Add a workspace
console.log('\n--- Adding Workspace ---');
const testWorkspace: Workspace = {
  id: crypto.randomUUID(),
  name: 'test-workspace',
  path: '/tmp/test-worktree',
  branch: 'feature/test',
  agent: 'claude',
  createdAt: new Date().toISOString(),
  lastActiveAt: new Date().toISOString(),
};

store.set(workspacesAtom, [...initialWorkspaces, testWorkspace]);
console.log('Added workspace:', testWorkspace.name);

// Test 3: Modify settings
console.log('\n--- Updating Settings ---');
store.set(settingsAtom, { ideCommand: 'cursor', defaultAgent: 'opencode' });
console.log('Settings updated');

// Test 4: Verify persistence by reading files directly
console.log('\n--- Verifying Disk Persistence ---');
const diskWorkspaces = fsStorage.getItem<Workspace[]>('workspaces', []);
const diskSettings = fsStorage.getItem<Settings>('settings', { ideCommand: '', defaultAgent: 'claude' });
console.log('Workspaces on disk:', diskWorkspaces.length, 'items');
console.log('Settings on disk:', JSON.stringify(diskSettings, null, 2));

// Test 5: Clean up test data
console.log('\n--- Cleanup ---');
store.set(workspacesAtom, initialWorkspaces); // Restore original
store.set(settingsAtom, initialSettings);
console.log('Restored original state');

console.log('\n=== Test Complete ===');
console.log('Restart this script to verify persistence survives process restart.');
```

Add to package.json scripts: "test:state": "node dist/state/test-state.js"
  </action>
  <verify>
Run `npm run build && npm run test:state`
Run again to verify state persists across restarts.
Check ~/.equipe/state/ directory contains workspaces.json and settings.json
  </verify>
  <done>
Test script creates workspace, modifies settings, verifies disk persistence.
State survives process restart (run test twice to confirm).
Files exist in ~/.equipe/state/ directory.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm run test:state` runs without errors
3. ~/.equipe/state/workspaces.json exists after test
4. ~/.equipe/state/settings.json exists after test
5. Running test twice shows state persisted between runs
</verification>

<success_criteria>
- FileSystemStorage adapter works in Node.js (no localStorage dependency)
- Jotai atoms persist to filesystem via atomWithStorage
- Workspaces array survives process restart
- Settings survive process restart
- Atomic writes prevent corruption (write-file-atomic used)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
